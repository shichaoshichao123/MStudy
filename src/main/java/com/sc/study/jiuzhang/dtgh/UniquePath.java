package com.sc.study.jiuzhang.dtgh;/** * @author yingqi * @date 2021/12/9 */public class UniquePath {    public static void main(String[] args) {    }    /**     * 计算从网格的左上角到指定坐标的路径（只能向下或向右走）     *     * @param brand     * @return     */    private int getUniquePathNums(int[][] brand) {        if (null == brand) {            return 0;        }        int row = brand.length;        int col = brand[0].length;        //用于存放状态        int[][] dp = new int[row][col];        //初始化边界值        for (int rowIndex = 0; rowIndex < row; rowIndex++) {            dp[rowIndex][0] = 1;        }        for (int colIndex = 0; colIndex < col; colIndex++) {            dp[0][colIndex] = 1;        }        for (int k = 1; k < row; k++) {            for (int l = 1; l < col; l++) {                dp[k][l] = dp[k - 1][l] + dp[k][l - 1];            }        }        return dp[row - 1][col - 1];    }    /**     * 有障碍的表格从左上角到有下角的可行路径     *     * @param brand     * @return     */    private static int getUniquePathNumsV2(int[][] brand) {        if (null == brand || brand.length == 0) {            return 0;        }        int row = brand.length;        int col = brand[0].length;        //初始化第一列的可行性        for (int i = 0; i < row; i++) {            if (brand[i][0] == 1) {                break;            }            brand[i][0] = 1;        }        for (int j = 0; j < col; j++) {            if (brand[0][j] == 1) {                break;            }            brand[0][j] = 1;        }        for (int i = 0; i < row; i++) {            for (int j = 0; j < col; j++) {                if (brand[i][j] == 1) {                    continue;                }                brand[i][j] = brand[i][j - 1] + brand[i - 1][j];            }        }        return brand[row - 1][col - 1];    }}