package com.sc.study.jiuzhang.tree.divide;import java.util.Stack;/** * @author yingqi * @date 2021/12/2 * 从BST中获取第K大的元素 */public class FindNoKNumInBST {    public static void main(String[] args) {    }    /**     * 使用非递归的中序便利去完成,进行k-1次出栈，留下来的栈顶元素就是第k大的元素     *     * @param root     * @return     */    public static int findNoK(BtreeNode root, int k) {        if (null == root) {            return -1;        }        Stack<BtreeNode> operatorStack = new Stack<>();        //先进行跟节点最左入栈        while (null != root) {            operatorStack.push(root);            root = root.left;        }        //进行k-1次的循环        for (int i = 0; i < k - 1; i++) {            //弹出栈顶元素            BtreeNode currentTop = operatorStack.pop();            //如果当前栈顶元素有又子树，再对其右子树进行最左入栈            if (null != currentTop.right) {                currentTop = currentTop.right;                while (null != currentTop) {                    operatorStack.push(currentTop);                    currentTop = currentTop.left;                }            }        }        return operatorStack.peek().value;    }}