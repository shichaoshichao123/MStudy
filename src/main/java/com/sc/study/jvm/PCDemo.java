package com.sc.study.jvm;import com.fasterxml.jackson.annotation.JsonFormat;import lombok.SneakyThrows;import java.util.ArrayList;import java.util.List;import java.util.Random;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * @author yingqi * @date 2021/12/4 * 实现一个生产者消费者的模型 */public class PCDemo {    private static final int MAX_SIZE = 12;    private static volatile List<Integer> queue = new ArrayList<>();    public static void main(String[] args) {        Producer producer = new Producer();        Consumer consumer = new Consumer();        Consumer consumer1 = new Consumer();        Consumer consumer2 = new Consumer();        producer.start();        consumer.start();        consumer1.start();        consumer2.start();        producer.isInterrupted();        ExecutorService executorService = Executors.newFixedThreadPool(100);        Future<?> future = executorService.submit(producer);        try {            future.get();        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }    }    static class Producer extends Thread {        @SneakyThrows        @Override        public void run() {            while (true) {                Thread.sleep(new Random().nextInt(1000));                synchronized (queue) {                    while (queue.size() == MAX_SIZE) {                        System.out.println("队列已满，停止生产...");                        try {                            queue.wait();                        } catch (InterruptedException e) {                        }                    }                    int data = new Random().nextInt(1000);                    System.out.println("开始生产数据:" + data);                    queue.add(data);                    queue.notifyAll();                }            }        }    }    static class Consumer extends Thread {        @SneakyThrows        @Override        public void run() {            while (true) {                Thread.sleep(new Random().nextInt(1000));                synchronized (queue) {                    while (queue.size() == 0) {                        System.out.println("队列为空没有产品可消费，停止消费...");                        try {                            queue.wait();                        } catch (InterruptedException e) {                        }                    }                    try {                        System.out.println("消费内容:" + queue.remove(0));                    } catch (Exception e) {                        e.printStackTrace();                    }                    queue.notifyAll();                }            }        }    }}